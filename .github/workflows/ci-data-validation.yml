name: CI Data Validation

on:
  pull_request:
  push:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-affiliations:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate affiliations.txt structure and categories
        run: |
          cat > validate_affiliations.py << 'EOF'
          import sys
          valid_categories = {'edu', 'partner', 'default'}
          with open('affiliations.txt') as f:
              lines = [l.strip() for l in f if l.strip() and not l.startswith('#')]
              for i, line in enumerate(lines, 1):
                  parts = [p.strip() for p in line.split('|')]
                  if len(parts) != 4:
                      print(f'Error: Line {i} does not have 4 fields (affiliation|message|category|domain): {line}')
                      sys.exit(1)
                  aff, msg, cat, domain = parts
                  if not aff or not msg or not cat:
                      print(f'Error: Line {i} has empty required fields (affiliation, message, category): {line}')
                      sys.exit(1)
                  if cat not in valid_categories:
                      print(f'Error: Line {i} has invalid category: {cat}')
                      sys.exit(1)
                  # Domain can be empty for some affiliations (like "default" category)
                  print(f'Line {i}: {aff} -> category: {cat}, domain: "{domain}"')
          print('affiliations.txt is valid.')
          EOF
          python3 validate_affiliations.py

  validate-events-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Validate live Events data from Apps Script and test filtering
        env:
          GOOGLE_SCRIPT_URL: ${{ secrets.GOOGLE_SCRIPT_URL }}
        run: |
          cat > validate_events.py << 'EOF'
          import json
          import urllib.request
          import os
          import sys
          
          script_url = os.environ.get('GOOGLE_SCRIPT_URL')
          if not script_url:
              print('GOOGLE_SCRIPT_URL secret not configured - skipping live data validation')
              sys.exit(0)
          
          required_columns = ['Title', 'Date', 'EDU code', 'Partner code', 'General URL', 'EDU URL', 'Partner URL']
          
          def is_event_complete(event):
              """Check if an event has all required columns with non-empty values"""
              for col in required_columns:
                  if col not in event or not event[col] or str(event[col]).strip() == '':
                      return False
              return True
          
          def filter_complete_events(events):
              """Filter events to include only complete ones (same logic as frontend/backend)"""
              complete_events = []
              for event in events:
                  if is_event_complete(event):
                      complete_events.append(event)
                  else:
                      # Log which events would be filtered out
                      missing_cols = []
                      for col in required_columns:
                          if col not in event or not event[col] or str(event[col]).strip() == '':
                              missing_cols.append(col)
                      print(f'  [INFO] Event would be filtered out - missing/empty: {missing_cols} - Title: {event.get("Title", "Unknown")}')
              return complete_events
          
          try:
              # Fetch data from Apps Script
              with urllib.request.urlopen(script_url) as response:
                  data = json.loads(response.read())
              
              if data.get('status') != 'success':
                  print(f'Apps Script returned error: {data}')
                  sys.exit(1)
              
              events = data.get('data', [])
              if not events:
                  print('No events found in Apps Script response')
                  sys.exit(1)
              
              print(f'Found {len(events)} events from Apps Script')
              
              # Test filtering logic (same as implemented in frontend/backend)
              print('\nTesting event filtering logic:')
              complete_events = filter_complete_events(events)
              print(f'Events after filtering: {len(complete_events)} complete events')
              
              # Validate that all returned events are actually complete
              # (This tests that our server-side filtering is working correctly)
              validation_errors = []
              for i, event in enumerate(events, 1):
                  event_title = event.get('Title', f'Event {i}')
                  
                  for col in required_columns:
                      if col not in event:
                          validation_errors.append(f'Event {i} ({event_title}): Missing column "{col}"')
                      elif not event[col] or str(event[col]).strip() == '':
                          validation_errors.append(f'Event {i} ({event_title}): Empty value in column "{col}"')
              
              if validation_errors:
                  print('\nValidation failed - Apps Script returned incomplete events:')
                  for error in validation_errors:
                      print(f'  - {error}')
                  print('\nThis indicates that server-side filtering is not working properly.')
                  sys.exit(1)
              
              # Success message
              print(f'\nâœ… Validation passed:')
              print(f'   - Apps Script returned {len(events)} events')
              print(f'   - All events have complete data (7 required columns)')
              print(f'   - Server-side filtering is working correctly')
              print(f'   - Client-side filtering logic tested and confirmed')
          
          except Exception as e:
              print(f'Error fetching or validating events data: {e}')
              sys.exit(1)
          EOF
          python3 validate_events.py 